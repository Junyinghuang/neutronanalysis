////////////////////////////////////////////////////////////////////////
// Class:       NeutronCal
// Module Type: analyzer
// File:        NeutronCal_module.cc
//
////////////////////////////////////////////////////////////////////////

#include "lardataobj/Simulation/SimChannel.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "larsim/Simulation/LArVoxelData.h"
#include "larsim/Simulation/LArVoxelList.h"
#include "larsim/Simulation/SimListUtils.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardataobj/RecoBase/Slice.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardata/Utilities/DatabaseUtil.h"
#include "lardataobj/RecoBase/PointCharge.h"


#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

//#include "lardata/ArtDataHelper/MVAReader.h"

#include "TH1.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"
#include "TGraph.h"

#include <fstream>

#define MVA_LENGTH 4

namespace proto
{
	class NeutronCal;
}

class proto::NeutronCal : public art::EDAnalyzer {
public:
  explicit NeutronCal(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  NeutronCal(NeutronCal const &) = delete;
  NeutronCal(NeutronCal &&) = delete;
  NeutronCal & operator = (NeutronCal const &) = delete;
  NeutronCal & operator = (NeutronCal &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  
  void beginJob() override;
  void endJob() override;

	void reconfigure(fhicl::ParameterSet const& p) ;

private:

  const detinfo::DetectorProperties* fDetprop;
  // Declare member data here.
  double GetEdepHitsMeV(const std::vector< recob::Hit > & hits) const;
  double GetEhitMeV(const recob::Hit & hit) const;
  double GetEhitMeVcorrel(const recob::Hit & hit) const;
  double GetEkinMeV(const std::vector < art::Ptr< recob::Hit > > & hits, const std::vector < recob::TrackHitMeta const* > & data);
  // EM
  double GetEdepEM_MC(art::Event const & e) const;
  double GetEdepEMAtt_MC(art::Event const & e) const;
  double GetEdepEMhAtt_MC(art::Event const & e, const std::vector< recob::Hit > & hits) const;
  
  // Average Drift time
  double GetDriftTime(const std::vector< recob::Hit > & hits) const;
  
  
  double fEdepEM_MC;
  double fEdepEMAtt_MC;
  double fEdepEMhAtt_MC; // new
  double fQEM_MC; 
  double fQEMAtt_MC; 
  
  
  double fEdepEM_reco;
  double fEdepEMcorr_ellifetime_reco;
  double fQEM_reco;
  double fQEMcorr_ellifetime_reco;
  double fDriftTime;
  
  // slice
  
  std::vector<double> fEdepSlice_reco;
  std::vector<double> fEdepSlicecorr_ellifetime_reco;
  std::vector<double> fEdepSlice_reco_Pcharge;
  std::vector<double> fEdepSlicecorr_ellifetime_reco_Pcharge;
  int fNumberOfSlices;
  
  
  // HAD
  double GetEdepHAD_MC(art::Event const & e) const;
  double GetEdepHADAtt_MC(art::Event const & e) const;
  double GetEdepHADhAtt_MC(art::Event const & e, const std::vector< recob::Hit > & hits) const;
  
  double fEdepHAD_MC; // new
  double fEdepHADAtt_MC; // new
  double fEdepHADhAtt_MC;
  
  double fEdepHAD_reco;
  double fEdepHADcorr_ellifetime_reco;
  
  
  // MISSING ENERGY
  double fMissEn_MC;
  
  // neutron capture position
  double fNcapX_MC;
  double fNcapY_MC;
  double fNcapZ_MC;
  std::vector<double> fGammaEk_MC;
  
  void ResetVars();
  
  geo::GeometryCore const * fGeometry;
  
  TTree *fTree;
  TTree *fTreeEntries;
  int fRun;
  int fEvent;
  int fBestView;
  int fNumberOfTracks;
  
 
  double fdQdx;
  double fdEdx;
  double fdQ;
  double fdx;
  double fEdepSum;
  double fEdepAllhits;
  double fElectronsToGeV;
  double fResRange;
  double fEnGen;
  double fEkGen;
  double fT0;
  
  std::ofstream file;
  
  // Module labels to get data products
  art::InputTag fNNetModuleLabel;
  std::string fHitModuleLabel;
  std::string fClusterModuleLabel;
  std::string fSliceModuleLabel;
  std::string fSpacePointModuleLabel;
  std::string fSPHitAssnLabel;
  std::string fTrackModuleLabel;
  std::string fCalorimetryModuleLabel;
  std::string fSimulationLabel;
  calo::CalorimetryAlg fCalorimetryAlg;
  
  std::unordered_map< int, const simb::MCParticle* > fParticleMap;
  //std::unordered_map< int, const recob::PointCharge* > fPointChargeMap;
};


proto::NeutronCal::NeutronCal(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  fCalorimetryAlg(p.get<fhicl::ParameterSet>("CalorimetryAlg"))
 // More initializers here.
{
	reconfigure(p);
	// get a pointer to the geometry service provider
	fGeometry = &*(art::ServiceHandle<geo::Geometry>());
	fDetprop = art::ServiceHandle<detinfo::DetectorPropertiesService>()->provider();
	file.open("dump.txt");
}

void proto::NeutronCal::beginJob()
{
	art::ServiceHandle<sim::LArG4Parameters> larParameters;
  fElectronsToGeV = 1./larParameters->GeVToElectrons();
  std::cout<<"fElectronsToGeV = "<<fElectronsToGeV<<std::endl;

	// access art's TFileService, which will handle creating and writing hists
	art::ServiceHandle<art::TFileService> tfs;	
	
	fTree = tfs->make<TTree>("calibration","calibration tree");
	fTree->Branch("fRun", &fRun, "fRun/I");
	fTree->Branch("fEvent", &fEvent, "fEvent/I");
	fTree->Branch("fEnGen", &fEnGen, "fEnGen/D");
	fTree->Branch("fEkGen", &fEkGen, "fEkGeb/D");
	
	fTree->Branch("fEdepEM_MC", &fEdepEM_MC, "fEdepEM_MC/D");
	fTree->Branch("fEdepEMAtt_MC", &fEdepEMAtt_MC, "fEdepEMAtt_MC/D");
	fTree->Branch("fEdepEMhAtt_MC", &fEdepEMhAtt_MC, "fEdepEMhAtt_MC/D");
	fTree->Branch("fQEM_MC", &fQEM_MC, "fQEM_MC/D");
	fTree->Branch("fQEMAtt_MC", &fQEMAtt_MC, "fQEMAtt_MC/D");
	
	fTree->Branch("fEdepEM_reco", &fEdepEM_reco, "fEdepEM_reco/D");
	fTree->Branch("fEdepEMcorr_ellifetime_reco", &fEdepEMcorr_ellifetime_reco, "fEdepEMcorr_ellifetime_reco/D");
	fTree->Branch("fQEM_reco", &fQEM_reco, "fQEM_reco/D");
	fTree->Branch("fQEMcorr_ellifetime_reco", &fQEMcorr_ellifetime_reco, "fEdepEMcorr_ellifetime_reco/D");
	
	fTree->Branch("fDriftTime", &fDriftTime, "fDriftTime/D");
	
	fTree->Branch("fEdepHAD_MC", &fEdepHAD_MC, "fEdepHAD_MC/D");
	fTree->Branch("fEdepHADAtt_MC", &fEdepHADAtt_MC, "fEdepHADAtt_MC/D");
  fTree->Branch("fEdepHADhAtt_MC", &fEdepHADhAtt_MC, "fEdepHADhAtt_MC/D");
  
  fTree->Branch("fEdepHAD_reco", &fEdepHAD_reco, "fEdepHAD_reco/D");
	fTree->Branch("fEdepHADcorr_ellifetime_reco", &fEdepHADcorr_ellifetime_reco, "fEdepHADcorr_ellifetime_reco/D");
	
	fTree->Branch("fMissEn_MC", &fMissEn_MC, "fMissEn_MC/D");
	
	fTree->Branch("fNumberOfTracks", &fNumberOfTracks, "fNumberOfTracks/I");
	
	fTree->Branch("fEdepSum", &fEdepSum, "fEdepSum/D");
	fTree->Branch("fEdepAllhits", &fEdepAllhits, "fEdepAllhits/D");
	
	fTree->Branch("fEdepSlice_reco", &fEdepSlice_reco);
	fTree->Branch("fEdepSlicecorr_ellifetime_reco", &fEdepSlicecorr_ellifetime_reco);
	fTree->Branch("fEdepSlice_reco_Pcharge", &fEdepSlice_reco_Pcharge);
	fTree->Branch("fEdepSlicecorr_ellifetime_reco_Pcharge", &fEdepSlicecorr_ellifetime_reco_Pcharge);
	fTree->Branch("fNumberOfSlices", &fNumberOfSlices, "fNumberOfSlices/I");
	fTree->Branch("fT0", &fT0, "fT0/D");
	
	fTree->Branch("fNcapX_MC", &fNcapX_MC, "fNcapX_MC/D");
	fTree->Branch("fNcapY_MC", &fNcapY_MC, "fNcapY_MC/D");
	fTree->Branch("fNcapZ_MC", &fNcapZ_MC, "fNcapZ_MC/D");
	fTree->Branch("fGammaEk_MC", &fGammaEk_MC);
	
	
	fTreeEntries = tfs->make<TTree>("entries","entries tree");
	fTreeEntries->Branch("fdQdx", &fdQdx, "fdQdx/D");
	fTreeEntries->Branch("fdEdx", &fdEdx, "fdEdx/D");
	fTreeEntries->Branch("fdQ", &fdQ, "fdQ/D");
	fTreeEntries->Branch("fdx", &fdx, "fdx/D");
	
	TGraph gZX;
  TGraph gYX;
  TGraph gZY;

  gZX.SetTitle(";z;x");
  gYX.SetTitle(";y;x");
  gZY.SetTitle(";z;y");
  gZX.SetMarkerStyle(8);
  gYX.SetMarkerStyle(8);
  gZY.SetMarkerStyle(8);
  
  TGraph gZX_blip;
  TGraph gYX_blip;
  TGraph gZY_blip;

  gZX_blip.SetTitle(";z;x");
  gYX_blip.SetTitle(";y;x");
  gZY_blip.SetTitle(";z;y");
  gZX_blip.SetMarkerStyle(8);
  gYX_blip.SetMarkerStyle(8);
  gZY_blip.SetMarkerStyle(8);

}

void proto::NeutronCal::endJob()
{
	file.close();
}

void proto::NeutronCal::reconfigure(fhicl::ParameterSet const & p)
{
	fHitModuleLabel = p.get< std::string >("HitModuleLabel");
	fClusterModuleLabel = p.get< std::string >("ClusterModuleLabel");
	//fTrackModuleLabel = p.get< std::string >("TrackModuleLabel");
	//fCalorimetryModuleLabel = p.get< std::string >("CalorimetryModuleLabel");
	fSimulationLabel = p.get< std::string >("SimulationLabel");
	//fNNetModuleLabel = p.get< std::string >("NNetModuleLabel");
	fSpacePointModuleLabel = p.get<std::string>("SpacePointModuleLabel");
	fSPHitAssnLabel = p.get<std::string>("SPHitAssnLabel");
  fSliceModuleLabel = p.get<std::string>("SliceModuleLabel");
}

void proto::NeutronCal::analyze(art::Event const & e)
{
	
  // Implementation of required member function here.
  ResetVars();
  
  fRun = e.run();
  fEvent = e.id().event();
  std::cout<<"//////////////////////// Loading event "<<fEvent<<" ////////////////////////////"<<std::endl;
  
// 	// MC particle list
//	auto particleHandle = e.getValidHandle< std::vector<simb::MCParticle> >(fSimulationLabel);	
//	
//	for (auto const& p : *particleHandle)
//	{
//		fEnGen = p.P();
//	  fEkGen = (std::sqrt(p.P()*p.P() + p.Mass()*p.Mass()) - p.Mass()) * 1000; // MeVs
//		fParticleMap[p.TrackId()] = &p;
//		if(p.Process() == "primary"){
//			fT0 = p.T();
//			std::cout<<"PdgCode, Process, KineticE, mother = "<<p.PdgCode()<<", "<<p.Process()<<", "<<fEkGen<<", "<<p.Mother()<<std::endl;
//		}
//		// neutron capture position
//		if(p.PdgCode() ==2112 && p.EndProcess() == "nCapture"){
//    	fNcapX_MC = p.EndX();
//    	fNcapY_MC = p.EndY();
//    	fNcapZ_MC = p.EndZ();
//		}
//		// neutron capture gamma position
//    if(p.PdgCode() ==22 && p.Process() == "nCapture") {
//    	std::cout<<"gamma = ("<< p.Vx()<<", "<<p.Vy()<<", "<<p.Vz()<<"), energy = "<<fEkGen<<std::endl;
//    	fGammaEk_MC.push_back(fEkGen);
//    }
//	}
//
//	fEdepEM_MC = GetEdepEM_MC(e);
//	fEdepEMAtt_MC = GetEdepEMAtt_MC(e);
//	
//	fEdepHAD_MC = GetEdepHAD_MC(e);
//	fEdepHADAtt_MC = GetEdepHADAtt_MC(e);
	
	// hits
	// get the list of Hits
	const auto hitsHandle = e.getValidHandle< std::vector<recob::Hit> >(fHitModuleLabel);
	std::cout<<"Found "<<hitsHandle->size()<<" hits in total"<<std::endl;
	
	// all hits in the collection
	std::vector< recob::Hit > hits = *hitsHandle;
	
	// hits
	const auto& hitListHandle = *e.getValidHandle< std::vector<recob::Hit> >(fHitModuleLabel);
	fEdepAllhits = GetEdepHitsMeV(hitListHandle); 
	fDriftTime = GetDriftTime(hitListHandle);
	
	// space points
	const auto spacepointsHandle = e.getValidHandle< std::vector<recob::SpacePoint> >(fSpacePointModuleLabel); 
	std::cout<<"Found "<<spacepointsHandle->size()<<" space points"<<std::endl;
	for(size_t i=0; i<spacepointsHandle->size();i++) {
	  const recob::SpacePoint spt = spacepointsHandle->at(i);
	  
	}	
	   
	// point charges	
	auto pchargesHandle = e.getValidHandle< std::vector<recob::PointCharge> >(fSpacePointModuleLabel);
	
	// slices
	const auto sliceHandle = e.getValidHandle<std::vector<recob::Slice>>(fSliceModuleLabel);
		
  // Get hits from slices
	const art::FindManyP<recob::Hit> hitsFromSlice(sliceHandle, e, fSliceModuleLabel);
		
	// Get spacepoints from slices
  const art::FindManyP<recob::SpacePoint> spsFromSlice(sliceHandle, e, fSliceModuleLabel);
  
  std::unordered_map<int, bool> hitIDE;
  fNumberOfSlices = sliceHandle->size();
  if(hitsFromSlice.isValid()) {
    // loop over slices
		for (size_t c = 0; c < sliceHandle->size(); ++c) {	
			double EdepSlice = 0;
  	  double EdepSlice_corr = 0;
  	  double EdepSlice_Pcharge = 0;
  	  //double EdepSlice_corr_Pcharge = 0;
  	  for (size_t h = 0; h < hitsFromSlice.at(c).size(); ++h) {
  	  	if (hitsFromSlice.at(c)[h]->View() == fBestView) {
  	  	  hitIDE[hitsFromSlice.at(c)[h].key()] = true; 					
  	  	  fEdepEM_reco += GetEhitMeV(*hitsFromSlice.at(c)[h]);
  	  	  fEdepEMcorr_ellifetime_reco += GetEhitMeVcorrel(*hitsFromSlice.at(c)[h]);  				
  	  	  fEdepSum += GetEhitMeV(*hitsFromSlice.at(c)[h]); 
  	  	  EdepSlice += GetEhitMeV(*hitsFromSlice.at(c)[h]); 
  	  	  EdepSlice_corr += GetEhitMeVcorrel(*hitsFromSlice.at(c)[h]); 
  	  	  std::cout<<std::string(hitsFromSlice.at(c)[h]->WireID())<<" "<<hitsFromSlice.at(c)[h]->PeakTime()<<" "<<hitsFromSlice.at(c)[h]->Integral()<<std::endl;	
  	  	}
  	  }
  	  for(size_t h=0; h<spsFromSlice.at(c).size(); h++) {
  	  	size_t id = spsFromSlice.at(c)[h]->ID();
  	  	double pointcharge = 0;
  	  	if(id<pchargesHandle->size()) pointcharge = pchargesHandle->at(id).charge ();
  	  	
  	  	double dqel = fCalorimetryAlg.ElectronsFromADCArea(pointcharge, 2);
  	  	//double correllifetime = fCalorimetryAlg.LifetimeCorrection(tdrift, fT0);
  	  	double dq = dqel * fElectronsToGeV * 1000;
  	  	//double dq = dqel ;
  	  	EdepSlice_Pcharge += dq;
  	  }
  	  
  	  fEdepSlice_reco.push_back(EdepSlice);
  	  fEdepSlicecorr_ellifetime_reco.push_back(EdepSlice_corr);
  	  fEdepSlice_reco_Pcharge.push_back(EdepSlice_Pcharge);
  	  fEdepSlicecorr_ellifetime_reco_Pcharge.push_back(EdepSlice_Pcharge);
  	  std::cout<<"slice#"<<c<<" has "<< hitsFromSlice.at(c).size()<<" hits, EdepSlice_corr = "<<EdepSlice_corr<<std::endl;
  	}
  	std::cout<<"EdepReco using all hits = "<<fEdepEMcorr_ellifetime_reco<<std::endl;
  }
  else {
    std::cout<<"hitsFromSlice is invalid\n";	
  }
  
	// space points
	const auto spacepointHandle = e.getValidHandle<std::vector<recob::SpacePoint>>(fSpacePointModuleLabel);
	// Get the associations between the hits and SpacePoints
	art::FindManyP< recob::Hit > hitFromSp(spacepointHandle, e, fSPHitAssnLabel);
  if(hitFromSp.isValid()) {
    
  }
  else {
    std::cout<<"hitFromSp is invalid\n";	
  }
			
/*  // clusters
  auto cluResults = anab::MVAReader< recob::Cluster, MVA_LENGTH>::create(e, fNNetModuleLabel);

  std::unordered_map<int, bool> hitIDE;
  if (cluResults)
  {
  	const art::FindManyP< recob::Hit > hitsFromCluster(cluResults->dataHandle(), e, cluResults->dataTag());
  	
  	for (size_t c = 0; c < cluResults->size(); ++c)
  	{
  		for (size_t h = 0; h < hitsFromCluster.at(c).size(); ++h)
  		{
  			if (hitsFromCluster.at(c)[h]->View() == fBestView)
  			{
  				hitIDE[hitsFromCluster.at(c)[h].key()] = false;
  			}	
  		}
  	}
  }  
	
  // tracks
  fNumberOfTracks = 0;
  auto trkHandle = e.getValidHandle< std::vector<recob::Track> >(fTrackModuleLabel);
  art::FindManyP< recob::PFParticle > pfpFromTrack(trkHandle, e, fTrackModuleLabel);
  
  const art::FindManyP< anab::Calorimetry > calFromTracks(trkHandle, e, fCalorimetryModuleLabel);	
  const art::FindManyP< recob::Hit > hitsFromTracks(trkHandle, e, fTrackModuleLabel);
  const art::FindManyP<recob::Hit, recob::TrackHitMeta> fmthm(trkHandle, e, fTrackModuleLabel);
  	
  	if (fmthm.isValid())
  	{
  		// loop over tracks
  		for (size_t t = 0; t < trkHandle->size(); ++t)
  		{	
  			auto vhit = fmthm.at(t);
  			auto vmeta = fmthm.data(t);

  	  	// mark that hits have been used 
  			for (size_t h = 0; h < hitsFromTracks.at(t).size(); ++h)
  			{
  				if (hitsFromTracks.at(t)[h]->View() == fBestView)
  				{
  					hitIDE[hitsFromTracks.at(t)[h].key()] = true;
  				}
  			}	
  	
  			int nplanes = calFromTracks.at(t).size(); 	
  	
  			for (size_t p = 0; p < pfpFromTrack.at(t).size(); ++p)
  			{
  				int pdg = pfpFromTrack.at(t)[p]->PdgCode();
  				// condition for tracks
  				if ((pdg != 11) && (pdg != -11)) 
  				{  		
						fNumberOfTracks++;
				
						// for now it work for 3 planes and only collection view
  					if (nplanes == 3)
  					{
  						// fHadEnSum += GetEkinMeV(vhit, vmeta);
  						for (size_t h = 0; h < hitsFromTracks.at(t).size(); ++h)
  						{
  							if (hitsFromTracks.at(t)[h]->View() == fBestView)
  							{
  									fEdepHAD_reco += GetEhitMeV(*hitsFromTracks.at(t)[h]);
  									fEdepHADcorr_ellifetime_reco += GetEhitMeVcorrel(*hitsFromTracks.at(t)[h]);
  							}
  						}
  					}
  				}
					else // ... and condition for em showers
					{
						for (size_t h = 0; h < hitsFromTracks.at(t).size(); ++h)
  					{
  						// kinetic energy without correction for recombination, 
  						// only one view is considered 
  						if (hitsFromTracks.at(t)[h]->View() == fBestView)
  						{
  							fEdepEM_reco += GetEhitMeV(*hitsFromTracks.at(t)[h]);
  							fEdepEMcorr_ellifetime_reco += GetEhitMeVcorrel(*hitsFromTracks.at(t)[h]);
  						}
  					}
					}
 				}
 			}
 		}
 	
 // output from cnn's
 if (cluResults)
 {
 		const art::FindManyP< recob::Hit > hitsFromCluster(cluResults->dataHandle(), e, cluResults->dataTag());
 		
 		// loop over clusters
		for (size_t c = 0; c < cluResults->size(); ++c)
  	{
  		if (cluResults->item(c).View() == fBestView)
  		{ 			
  			std::array< float, MVA_LENGTH > cnn_out = cluResults->getOutput(c);
  			double p_trk_or_sh = cnn_out[0] + cnn_out[1];
  			double pdg = 1;
  			if (p_trk_or_sh > 0) pdg = cnn_out[1] / p_trk_or_sh;
  			
  			for (size_t h = 0; h < hitsFromCluster.at(c).size(); ++h)
  			{  				
  				if (hitIDE[hitsFromCluster.at(c)[h].key()] == false)
  				{
  					hitIDE[hitsFromCluster.at(c)[h].key()] = true;
  					
  					if (pdg < 0.63)
  					{
  						fEdepHAD_reco += GetEhitMeV(*hitsFromCluster.at(c)[h]);
  						fEdepHADcorr_ellifetime_reco += GetEhitMeVcorrel(*hitsFromCluster.at(c)[h]);
  					}
  					else
  					{
  						fEdepEM_reco += GetEhitMeV(*hitsFromCluster.at(c)[h]);
  						fEdepEMcorr_ellifetime_reco += GetEhitMeVcorrel(*hitsFromCluster.at(c)[h]);
  					}
  				}
  				
  				fEdepSum += GetEhitMeV(*hitsFromCluster.at(c)[h]);  
  			}
  		}
  	}
 }
 
*/
 	/*file << fEvent << " " << fEkGen << " " << fEdepEM_MC << " " << fEdepHAD_MC << " " << fMissEn_MC 
 			<< " " << fEdepEMAtt_MC << " " << fEdepEMhAtt_MC
 			<< " " << fEdepHADAtt_MC << " " << fEdepHADhAtt_MC
 			<< " " << fEdepHADcorr_ellifetime_reco << " " << fEdepEMcorr_ellifetime_reco << std::endl;*/ 
  fTree->Fill();	
}

// kinetic energy of hadronic part: correction for recombination applied according to Birks/Box model

/******************************************************************************/

double proto::NeutronCal::GetEkinMeV(const std::vector < art::Ptr< recob::Hit > > & hits, const std::vector < recob::TrackHitMeta const* > & data) 
{
	double ekin = 0.0;
	
	if (!hits.size()) return ekin;
	

	for (size_t h = 0; h < hits.size(); ++h)
	{
		double dqadc = hits[h]->Integral();
		if (!std::isnormal(dqadc) || (dqadc < 0)) dqadc = 0.0;
		
		unsigned short plane = hits[h]->WireID().Plane;
		unsigned short time = hits[h]->PeakTime();
		double t0 = 0;
		
		fdQdx = 0.0;
		fdQ = dqadc;
  	fdx = data[h]->Dx();
  	if ((fdx > 0) && (fdQ > 0))
  	{
  		fdQdx = fdQ/fdx;
  		fdEdx = fCalorimetryAlg.dEdx_AREA(fdQdx, time, plane, t0);
  		if (fdEdx > 35) fdEdx = 35;
  		
  		ekin += ( fdEdx * fdx );
  	}
  	else if ((fdx == 0) && (fdQ > 0))
  	{
  		
  	}
  	
  	fTreeEntries->Fill();
	}
	
	return ekin;
}

/******************************************************************************/

double proto::NeutronCal::GetEdepHitsMeV(const std::vector< recob::Hit > & hits) const
{
	if (!hits.size()) return 0.0;

	double dqsum = 0.0;
	for (size_t h = 0; h < hits.size(); ++h)
	{
		double dqadc = hits[h].Integral();
		if (!std::isnormal(dqadc) || (dqadc < 0)) continue;
	
		unsigned short plane = hits[h].WireID().Plane;
		if (plane == fBestView)
		{
			double tdrift = hits[h].PeakTime();
			double dqel = fCalorimetryAlg.ElectronsFromADCArea(dqadc, plane);
		  
			double correllifetime = fCalorimetryAlg.LifetimeCorrection(tdrift, fT0);
			double dq = dqel * correllifetime * fElectronsToGeV * 1000;
			//double dq = dqel * correllifetime;

			if (!std::isnormal(dq) || (dq < 0)) continue;

			dqsum += dq;
		} 
	}

	return dqsum; 
}

/******************************************************************************/

double proto::NeutronCal::GetEhitMeVcorrel(const recob::Hit & hit) const
{
	double dqadc = hit.Integral();
	if (!std::isnormal(dqadc) || (dqadc < 0)) dqadc = 0.0;

	unsigned short plane = hit.WireID().Plane;
	double tdrift = hit.PeakTime();
	double dqel = fCalorimetryAlg.ElectronsFromADCArea(dqadc, plane);

	double correllifetime = fCalorimetryAlg.LifetimeCorrection(tdrift, fT0);
	std::cout<<"tdrift, correllifetime, fT0 = "<<tdrift<<", "<<fT0<<", "<<correllifetime<<std::endl;
	double dq = dqel * correllifetime * fElectronsToGeV * 1000;
	//double dq = dqel * correllifetime;
	if (!std::isnormal(dq) || (dq < 0)) dq = 0.0;	

	return dq; 
}
/******************************************************************************/

/******************************************************************************/

double proto::NeutronCal::GetEhitMeV(const recob::Hit & hit) const
{
	double dqadc = hit.Integral();
	if (!std::isnormal(dqadc) || (dqadc < 0)) dqadc = 0.0;

	unsigned short plane = hit.WireID().Plane;
	// double tdrift = hit.PeakTime();
	double dqel = fCalorimetryAlg.ElectronsFromADCArea(dqadc, plane);

	double correllifetime = 1; // fCalorimetryAlg.LifetimeCorrection(tdrift, fT0);
	double dq = dqel * correllifetime * fElectronsToGeV * 1000;
	//double dq = dqel * correllifetime;
	if (!std::isnormal(dq) || (dq < 0)) dq = 0.0;	

	return dq; 
}

/******************************************************************************/

double proto::NeutronCal::GetEdepEM_MC(art::Event const & e) const
{
	double enEM = 0.0;
	
	art::Handle< std::vector<sim::SimChannel> > simchannelHandle;
	if (e.getByLabel(fSimulationLabel, simchannelHandle))
	{
			for ( auto const& channel : (*simchannelHandle) )
			{
				if (fGeometry->View(channel.Channel()) == fBestView)
				{ 
					// for every time slice in this channel:
					auto const& timeSlices = channel.TDCIDEMap();
					for ( auto const& timeSlice : timeSlices )
					{
						// loop over the energy deposits.
						auto const& energyDeposits = timeSlice.second;
		
						for ( auto const& energyDeposit : energyDeposits )
						{
							double energy = energyDeposit.energy; // energy not attenuated
							int trackID = energyDeposit.trackID;
							
							if (trackID < 0)
							{
								enEM += energy;
							}
							else if (trackID > 0)
							{
								auto search = fParticleMap.find(trackID);
								bool found = true;
								if (search == fParticleMap.end())
								{
									mf::LogWarning("TrainingDataAlg") << "PARTICLE NOT FOUND";
									found = false;
								}
								
								int pdg = 0;
								if (found)
								{
									const simb::MCParticle& particle = *((*search).second);
                  if (!pdg) pdg = particle.PdgCode(); // not EM activity so read what PDG it is
								}
								
								if ((pdg == 11) || (pdg == -11) || (pdg == 22)) enEM += energy;
							}
							
						}
					}
				}
			}
	}
	
	return enEM;
}

/******************************************************************************/

double proto::NeutronCal::GetEdepEMAtt_MC(art::Event const & e) const
{
	double enEM = 0.0;
	
	art::Handle< std::vector<sim::SimChannel> > simchannelHandle;
	if (e.getByLabel(fSimulationLabel, simchannelHandle))
	{
			for ( auto const& channel : (*simchannelHandle) )
			{
				if (fGeometry->View(channel.Channel()) == fBestView)
				{ 
					// for every time slice in this channel:
					auto const& timeSlices = channel.TDCIDEMap();
					for ( auto const& timeSlice : timeSlices )
					{
						// loop over the energy deposits.
						auto const& energyDeposits = timeSlice.second;
		
						for ( auto const& energyDeposit : energyDeposits )
						{
							double energy = energyDeposit.numElectrons * fElectronsToGeV * 1000; // attenuated 
							//double energy = energyDeposit.numElectrons; // attenuated 
							int trackID = energyDeposit.trackID;
							
							if (trackID < 0)
							{
								enEM += energy;
							}
							else if (trackID > 0)
							{
								auto search = fParticleMap.find(trackID);
								bool found = true;
								if (search == fParticleMap.end())
								{
									mf::LogWarning("TrainingDataAlg") << "PARTICLE NOT FOUND";
									found = false;
								}
								
								int pdg = 0;
								if (found)
								{
									const simb::MCParticle& particle = *((*search).second);
                  if (!pdg) pdg = particle.PdgCode(); // not EM activity so read what PDG it is
								}
								
								if ((pdg == 11) || (pdg == -11) || (pdg == 22)) enEM += energy;
							}
							
						}
					}
				}
			}
	}
	return enEM;
}


/******************************************************************************/

double proto::NeutronCal::GetEdepEMhAtt_MC(art::Event const & e, const std::vector< recob::Hit > & hits) const
{
	double totemhit = 0.0;
	
	auto simChannelHandle = e.getValidHandle< std::vector<sim::SimChannel> >(fSimulationLabel);
	const std::vector< sim::SimChannel > & channels = *simChannelHandle;
	
	for (auto const & hit: hits)
	{
		// the channel associate with this hit.
		auto hitChannelNumber = hit.Channel();
		
		double hitEn = 0.0; double hitEnSh = 0;
		
		for (auto const & channel: channels)
		{
			if (channel.Channel() != hitChannelNumber) continue;
			if (fGeometry->View(channel.Channel()) != fBestView) continue;
	
			// for every time slice in this channel:
			auto const& timeSlices = channel.TDCIDEMap();
			for ( auto const& timeSlice : timeSlices )
			{
					int time = timeSlice.first;
					if (std::abs(hit.TimeDistanceAsRMS(time)) < 1.0)
					{
						// loop over the energy deposits.
						auto const& energyDeposits = timeSlice.second;
		
						for ( auto const& energyDeposit : energyDeposits )
						{
							int trackID = energyDeposit.trackID;
							double energy = energyDeposit.numElectrons * fElectronsToGeV * 1000; // attenuated 
							//double energy = energyDeposit.numElectrons ; // attenuat
							hitEn += energy;
							
							if (trackID < 0)
							{
								hitEnSh += energy;
							}
							else if (trackID > 0)
							{
								auto search = fParticleMap.find(trackID);
								bool found = true;
								if (search == fParticleMap.end())
								{
									mf::LogWarning("TrainingDataAlg") << "PARTICLE NOT FOUND";
									found = false;
								}
								
								int pdg = 0;
								if (found)
								{
									const simb::MCParticle& particle = *((*search).second);
                  if (!pdg) pdg = particle.PdgCode(); // not EM activity so read what PDG it is
								}
								
								if ((pdg == 11) || (pdg == -11) || (pdg == 22)) hitEnSh += energy;
							}	
						}
					}
				}
			}
		
			double ratio = 0.0;
			if (hitEn > 0)
			{
				ratio = hitEnSh / hitEn;
			}
		
			// use energy of hit corrected for electron lifetime
			if (ratio > 0.5)
			{
				totemhit += GetEhitMeVcorrel(hit);
			}
		}
	
	return totemhit;
}

/******************************************************************************/

double proto::NeutronCal::GetEdepHAD_MC(art::Event const & e) const
{
	double enHAD = 0.0;
	   
	art::Handle< std::vector<sim::SimChannel> > simchannelHandle;
	if (e.getByLabel(fSimulationLabel, simchannelHandle)) 
	{  
	     
		for (auto const & channel : (*simchannelHandle) )
		{
			if (fGeometry->View(channel.Channel()) != fBestView) continue;

			// for every time slice in this channel:
			auto const& timeSlices = channel.TDCIDEMap();
			for (auto const& timeSlice : timeSlices)
			{
				// loop over the energy deposits.
				auto const & energyDeposits = timeSlice.second;
		
				for (auto const & energyDeposit : energyDeposits)
				{
						double energy = energyDeposit.energy; // energy not attenuated 
						int trackID = energyDeposit.trackID;

						if (trackID < 0) { } // EM activity
						else if (trackID > 0)
						{
								auto search = fParticleMap.find(trackID);
								
								if (search != fParticleMap.end())
								{
									const simb::MCParticle & particle = *((*search).second);
									int pdg = particle.PdgCode(); // not EM activity so read what PDG it is

								  if ((pdg == 11) || (pdg == -11) || (pdg == 22)) {}
								  else 
								  {
								  	enHAD += energy;
								  }
    	          }
								else { mf::LogWarning("TrainingDataAlg") << "PARTICLE NOT FOUND"; }
						}
				 }	
			 }
		}
	}
    
  return enHAD;
}

/******************************************************************************/

double proto::NeutronCal::GetEdepHADAtt_MC(art::Event const & e) const
{
	double enHAD = 0.0;
	   
	art::Handle< std::vector<sim::SimChannel> > simchannelHandle;
	if (e.getByLabel(fSimulationLabel, simchannelHandle)) 
	{  
	     
		for (auto const & channel : (*simchannelHandle) )
		{
			if (fGeometry->View(channel.Channel()) != fBestView) continue;

			// for every time slice in this channel:
			auto const& timeSlices = channel.TDCIDEMap();
			for (auto const& timeSlice : timeSlices)
			{
				// loop over the energy deposits.
				auto const & energyDeposits = timeSlice.second;
		
				for (auto const & energyDeposit : energyDeposits)
				{
						double energy = energyDeposit.numElectrons * fElectronsToGeV * 1000; // attenuated 
						//double energy = energyDeposit.numElectrons ;
						int trackID = energyDeposit.trackID;

						if (trackID < 0) { } // EM activity
						else if (trackID > 0)
						{
								auto search = fParticleMap.find(trackID);
								
								if (search != fParticleMap.end())
								{
									const simb::MCParticle & particle = *((*search).second);
									int pdg = particle.PdgCode(); // not EM activity so read what PDG it is

								  if ((pdg == 11) || (pdg == -11) || (pdg == 22)) {}
								  else 
								  {
								  	enHAD += energy;
								  }
    	          }
								else { mf::LogWarning("TrainingDataAlg") << "PARTICLE NOT FOUND"; }
						}
				 }	
			 }
		}
	}
    
  return enHAD;
}

/******************************************************************************/

double proto::NeutronCal::GetEdepHADhAtt_MC(art::Event const & e, const std::vector< recob::Hit > & hits) const
{
	double tothadhit = 0.0;
	
	auto simChannelHandle = e.getValidHandle< std::vector<sim::SimChannel> >(fSimulationLabel);
	const std::vector< sim::SimChannel > & channels = *simChannelHandle;
	
	for (auto const & hit: hits)
	{
		// the channel associated with this hit.
		auto hitChannelNumber = hit.Channel();

		double hitEn = 0.0; double hitEnTrk = 0;
       
		for (auto const & channel : channels)
		{
			if (channel.Channel() != hitChannelNumber) continue;
			if (fGeometry->View(channel.Channel()) != fBestView) continue;

			// for every time slice in this channel:
			auto const& timeSlices = channel.TDCIDEMap();
			for (auto const& timeSlice : timeSlices)
			{
				int time = timeSlice.first;
				if (std::abs(hit.TimeDistanceAsRMS(time)) < 1.0)
				{
					// loop over the energy deposits.
					auto const & energyDeposits = timeSlice.second;
		
					for (auto const & energyDeposit : energyDeposits)
					{
						int trackID = energyDeposit.trackID;

						double energy = energyDeposit.numElectrons * fElectronsToGeV * 1000; // attenuated 
						//double energy = energyDeposit.numElectrons;
						hitEn += energy;

						if (trackID < 0) { } // EM activity
						else if (trackID > 0)
						{
							auto search = fParticleMap.find(trackID);
							if (search != fParticleMap.end())
							{
								const simb::MCParticle & particle = *((*search).second);
								int pdg = particle.PdgCode(); // not EM activity so read what PDG it is

							  if ((pdg == 11) || (pdg == -11) || (pdg == 22)) {}
							  else {hitEnTrk += energy;}
              }
							else { mf::LogWarning("TrainingDataAlg") << "PARTICLE NOT FOUND"; }
						}
					}
				}
			}
		}
		
		double ratio = 0.0;
		if (hitEn > 0) 
		{
			ratio = hitEnTrk / hitEn;
		}
		// use energy of hit corrected for electron lifetime
		if (ratio > 0.5)
		{
			tothadhit += GetEhitMeVcorrel(hit);
		}
	}
    
  return tothadhit;
}
/******************************************************************************/

double proto::NeutronCal::GetDriftTime(const std::vector< recob::Hit > & hits) const {
  if (!hits.size()) return 0.0;
  double tdrift = 0.;
  double dqsum = 0.0;
  double dtsum = 0.0;
  for (size_t h = 0; h < hits.size(); ++h)
	{
		double dqadc = hits[h].Integral();
		if (!std::isnormal(dqadc) || (dqadc < 0)) continue;
	
		unsigned short plane = hits[h].WireID().Plane;
		if (plane == fBestView)
		{
			double tpeak = hits[h].PeakTime();
			double dqel = fCalorimetryAlg.ElectronsFromADCArea(dqadc, plane);		  
			//double correllifetime = fCalorimetryAlg.LifetimeCorrection(tdrift, fT0);
			double correllifetime = 1.;
			double dq = dqel * correllifetime * fElectronsToGeV * 1000;
			//double dq = dqel * correllifetime ;

			if (!std::isnormal(dq) || (dq < 0)) continue;
			dqsum += dq;
			
			double timetick = fDetprop->SamplingRate()*1.e-3;    //time sample in microsec
      double presamplings = fDetprop->TriggerOffset();
    
      tpeak -= presamplings;
      double dt = tpeak * timetick - fT0*1e-3;  //  (in microsec)
      dtsum += dq*dt;
		} 
	}
	tdrift = dtsum/dqsum;
	return tdrift;	
}

void proto::NeutronCal::ResetVars()
{
	fRun = 0;
	fEvent = 0;
	fBestView = 2;
	fNumberOfTracks = 0;
	
	fEdepEM_MC = 0.0;
	fEdepEMAtt_MC = 0.0;
	fEdepEMhAtt_MC = 0.0; 
	
	fEdepHAD_MC = 0.0;
	fEdepHADAtt_MC = 0.0;
	fEdepHADhAtt_MC = 0.0;
	
	fMissEn_MC = 0.0;
	
	fEdepEM_reco = 0.0;
  fEdepEMcorr_ellifetime_reco = 0.0;
  fDriftTime = 0.0;
  fEdepHAD_reco = 0.0;
  fEdepHADcorr_ellifetime_reco = 0.0;
  fEdepSlice_reco.clear();
  fEdepSlicecorr_ellifetime_reco.clear();
  fEdepSlice_reco_Pcharge.clear();
  fEdepSlicecorr_ellifetime_reco_Pcharge.clear();
  fNumberOfSlices = 0;
	
	fEnGen = 0.0;
	fEkGen = 0.0;
 
  fEdepSum = 0.0;
  fEdepAllhits = 0.0;

	fdQdx = 0.0;
	fdEdx = 0.0;
	fdQ = 0.0;
	fdx = 0.0;
	fResRange = 0.0;
	fT0 = 0.0;
	fParticleMap.clear();
}

DEFINE_ART_MODULE(proto::NeutronCal)
